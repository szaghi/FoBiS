/******************************************************************************
 * This file was generated by langium-cli 4.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import * as langium from '../../syntax-tree.js';
export declare const LangiumGrammarTerminals: {
    ID: RegExp;
    STRING: RegExp;
    NUMBER: RegExp;
    RegexLiteral: RegExp;
    WS: RegExp;
    ML_COMMENT: RegExp;
    SL_COMMENT: RegExp;
};
export type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;
export type LangiumGrammarKeywordNames = "!" | "&" | "(" | ")" | "*" | "+" | "+=" | "," | "->" | "." | ".." | ":" | ";" | "<" | "=" | "=>" | ">" | "?" | "?!" | "?<!" | "?<=" | "?=" | "@" | "Date" | "EOF" | "[" | "]" | "assoc" | "bigint" | "boolean" | "current" | "entry" | "extends" | "false" | "fragment" | "grammar" | "hidden" | "import" | "infer" | "infers" | "infix" | "interface" | "left" | "number" | "on" | "returns" | "right" | "string" | "terminal" | "true" | "type" | "with" | "{" | "|" | "}";
export type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;
export interface AbstractElement extends langium.AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalElement' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
}
export declare const AbstractElement: {
    readonly $type: "AbstractElement";
    readonly cardinality: "cardinality";
};
export declare function isAbstractElement(item: unknown): item is AbstractElement;
export type AbstractParserRule = InfixRule | ParserRule;
export declare const AbstractParserRule: {
    readonly $type: "AbstractParserRule";
};
export declare function isAbstractParserRule(item: unknown): item is AbstractParserRule;
export type AbstractRule = AbstractParserRule | TerminalRule;
export declare const AbstractRule: {
    readonly $type: "AbstractRule";
};
export declare function isAbstractRule(item: unknown): item is AbstractRule;
export type AbstractType = AbstractParserRule | InferredType | Interface | Type;
export declare const AbstractType: {
    readonly $type: "AbstractType";
};
export declare function isAbstractType(item: unknown): item is AbstractType;
export interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: langium.Reference<AbstractType>;
}
export declare const Action: {
    readonly $type: "Action";
    readonly cardinality: "cardinality";
    readonly feature: "feature";
    readonly inferredType: "inferredType";
    readonly operator: "operator";
    readonly type: "type";
};
export declare function isAction(item: unknown): item is Action;
export interface Alternatives extends AbstractElement {
    readonly $type: 'Alternatives';
    elements: Array<AbstractElement>;
}
export declare const Alternatives: {
    readonly $type: "Alternatives";
    readonly cardinality: "cardinality";
    readonly elements: "elements";
};
export declare function isAlternatives(item: unknown): item is Alternatives;
export interface ArrayLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}
export declare const ArrayLiteral: {
    readonly $type: "ArrayLiteral";
    readonly elements: "elements";
};
export declare function isArrayLiteral(item: unknown): item is ArrayLiteral;
export interface ArrayType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}
export declare const ArrayType: {
    readonly $type: "ArrayType";
    readonly elementType: "elementType";
};
export declare function isArrayType(item: unknown): item is ArrayType;
export interface Assignment extends AbstractElement {
    readonly $type: 'Assignment';
    feature: FeatureName;
    operator: '+=' | '=' | '?=';
    predicate?: '->' | '=>';
    terminal: AbstractElement;
}
export declare const Assignment: {
    readonly $type: "Assignment";
    readonly cardinality: "cardinality";
    readonly feature: "feature";
    readonly operator: "operator";
    readonly predicate: "predicate";
    readonly terminal: "terminal";
};
export declare function isAssignment(item: unknown): item is Assignment;
export type Associativity = 'left' | 'right';
export interface BooleanLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}
export declare const BooleanLiteral: {
    readonly $type: "BooleanLiteral";
    readonly true: "true";
};
export declare function isBooleanLiteral(item: unknown): item is BooleanLiteral;
export interface CharacterRange extends TerminalElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}
export declare const CharacterRange: {
    readonly $type: "CharacterRange";
    readonly cardinality: "cardinality";
    readonly left: "left";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
    readonly right: "right";
};
export declare function isCharacterRange(item: unknown): item is CharacterRange;
export type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;
export declare const Condition: {
    readonly $type: "Condition";
};
export declare function isCondition(item: unknown): item is Condition;
export interface Conjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}
export declare const Conjunction: {
    readonly $type: "Conjunction";
    readonly left: "left";
    readonly right: "right";
};
export declare function isConjunction(item: unknown): item is Conjunction;
export interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    isMulti: boolean;
    terminal?: AbstractElement;
    type: langium.Reference<AbstractType>;
}
export declare const CrossReference: {
    readonly $type: "CrossReference";
    readonly cardinality: "cardinality";
    readonly deprecatedSyntax: "deprecatedSyntax";
    readonly isMulti: "isMulti";
    readonly terminal: "terminal";
    readonly type: "type";
};
export declare function isCrossReference(item: unknown): item is CrossReference;
export interface Disjunction extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}
export declare const Disjunction: {
    readonly $type: "Disjunction";
    readonly left: "left";
    readonly right: "right";
};
export declare function isDisjunction(item: unknown): item is Disjunction;
export interface EndOfFile extends AbstractElement {
    readonly $type: 'EndOfFile';
}
export declare const EndOfFile: {
    readonly $type: "EndOfFile";
    readonly cardinality: "cardinality";
};
export declare function isEndOfFile(item: unknown): item is EndOfFile;
export type FeatureName = 'assoc' | 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'infix' | 'interface' | 'left' | 'on' | 'returns' | 'right' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;
export interface Grammar extends langium.AstNode {
    readonly $type: 'Grammar';
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
}
export declare const Grammar: {
    readonly $type: "Grammar";
    readonly imports: "imports";
    readonly interfaces: "interfaces";
    readonly isDeclared: "isDeclared";
    readonly name: "name";
    readonly rules: "rules";
    readonly types: "types";
};
export declare function isGrammar(item: unknown): item is Grammar;
export interface GrammarImport extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}
export declare const GrammarImport: {
    readonly $type: "GrammarImport";
    readonly path: "path";
};
export declare function isGrammarImport(item: unknown): item is GrammarImport;
export interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
    predicate?: '->' | '=>';
}
export declare const Group: {
    readonly $type: "Group";
    readonly cardinality: "cardinality";
    readonly elements: "elements";
    readonly guardCondition: "guardCondition";
    readonly predicate: "predicate";
};
export declare function isGroup(item: unknown): item is Group;
export interface InferredType extends langium.AstNode {
    readonly $container: Action | InfixRule | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}
export declare const InferredType: {
    readonly $type: "InferredType";
    readonly name: "name";
};
export declare function isInferredType(item: unknown): item is InferredType;
export interface InfixRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'InfixRule';
    call: RuleCall;
    dataType?: PrimitiveType;
    inferredType?: InferredType;
    name: string;
    operators: InfixRuleOperators;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}
export declare const InfixRule: {
    readonly $type: "InfixRule";
    readonly call: "call";
    readonly dataType: "dataType";
    readonly inferredType: "inferredType";
    readonly name: "name";
    readonly operators: "operators";
    readonly parameters: "parameters";
    readonly returnType: "returnType";
};
export declare function isInfixRule(item: unknown): item is InfixRule;
export interface InfixRuleOperatorList extends langium.AstNode {
    readonly $container: InfixRuleOperators;
    readonly $type: 'InfixRuleOperatorList';
    associativity?: Associativity;
    operators: Array<Keyword>;
}
export declare const InfixRuleOperatorList: {
    readonly $type: "InfixRuleOperatorList";
    readonly associativity: "associativity";
    readonly operators: "operators";
};
export declare function isInfixRuleOperatorList(item: unknown): item is InfixRuleOperatorList;
export interface InfixRuleOperators extends langium.AstNode {
    readonly $container: InfixRule;
    readonly $type: 'InfixRuleOperators';
    precedences: Array<InfixRuleOperatorList>;
}
export declare const InfixRuleOperators: {
    readonly $type: "InfixRuleOperators";
    readonly precedences: "precedences";
};
export declare function isInfixRuleOperators(item: unknown): item is InfixRuleOperators;
export interface Interface extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<langium.Reference<AbstractType>>;
}
export declare const Interface: {
    readonly $type: "Interface";
    readonly attributes: "attributes";
    readonly name: "name";
    readonly superTypes: "superTypes";
};
export declare function isInterface(item: unknown): item is Interface;
export interface Keyword extends AbstractElement {
    readonly $container: CharacterRange | InfixRuleOperatorList;
    readonly $type: 'Keyword';
    predicate?: '->' | '=>';
    value: string;
}
export declare const Keyword: {
    readonly $type: "Keyword";
    readonly cardinality: "cardinality";
    readonly predicate: "predicate";
    readonly value: "value";
};
export declare function isKeyword(item: unknown): item is Keyword;
export interface NamedArgument extends langium.AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: langium.Reference<Parameter>;
    value: Condition;
}
export declare const NamedArgument: {
    readonly $type: "NamedArgument";
    readonly calledByName: "calledByName";
    readonly parameter: "parameter";
    readonly value: "value";
};
export declare function isNamedArgument(item: unknown): item is NamedArgument;
export interface NegatedToken extends TerminalElement {
    readonly $type: 'NegatedToken';
    terminal: AbstractElement;
}
export declare const NegatedToken: {
    readonly $type: "NegatedToken";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
    readonly terminal: "terminal";
};
export declare function isNegatedToken(item: unknown): item is NegatedToken;
export interface Negation extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}
export declare const Negation: {
    readonly $type: "Negation";
    readonly value: "value";
};
export declare function isNegation(item: unknown): item is Negation;
export interface NumberLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}
export declare const NumberLiteral: {
    readonly $type: "NumberLiteral";
    readonly value: "value";
};
export declare function isNumberLiteral(item: unknown): item is NumberLiteral;
export interface Parameter extends langium.AstNode {
    readonly $container: InfixRule | ParserRule;
    readonly $type: 'Parameter';
    name: string;
}
export declare const Parameter: {
    readonly $type: "Parameter";
    readonly name: "name";
};
export declare function isParameter(item: unknown): item is Parameter;
export interface ParameterReference extends langium.AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: langium.Reference<Parameter>;
}
export declare const ParameterReference: {
    readonly $type: "ParameterReference";
    readonly parameter: "parameter";
};
export declare function isParameterReference(item: unknown): item is ParameterReference;
export interface ParserRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: langium.Reference<AbstractType>;
}
export declare const ParserRule: {
    readonly $type: "ParserRule";
    readonly dataType: "dataType";
    readonly definition: "definition";
    readonly entry: "entry";
    readonly fragment: "fragment";
    readonly inferredType: "inferredType";
    readonly name: "name";
    readonly parameters: "parameters";
    readonly returnType: "returnType";
};
export declare function isParserRule(item: unknown): item is ParserRule;
export type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';
export interface ReferenceType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    isMulti: boolean;
    referenceType: TypeDefinition;
}
export declare const ReferenceType: {
    readonly $type: "ReferenceType";
    readonly isMulti: "isMulti";
    readonly referenceType: "referenceType";
};
export declare function isReferenceType(item: unknown): item is ReferenceType;
export interface RegexToken extends TerminalElement {
    readonly $type: 'RegexToken';
    regex: string;
}
export declare const RegexToken: {
    readonly $type: "RegexToken";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
    readonly regex: "regex";
};
export declare function isRegexToken(item: unknown): item is RegexToken;
export interface ReturnType extends langium.AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}
export declare const ReturnType: {
    readonly $type: "ReturnType";
    readonly name: "name";
};
export declare function isReturnType(item: unknown): item is ReturnType;
export interface RuleCall extends AbstractElement {
    readonly $container: InfixRule;
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    predicate?: '->' | '=>';
    rule: langium.Reference<AbstractRule>;
}
export declare const RuleCall: {
    readonly $type: "RuleCall";
    readonly arguments: "arguments";
    readonly cardinality: "cardinality";
    readonly predicate: "predicate";
    readonly rule: "rule";
};
export declare function isRuleCall(item: unknown): item is RuleCall;
export interface SimpleType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: langium.Reference<AbstractType>;
}
export declare const SimpleType: {
    readonly $type: "SimpleType";
    readonly primitiveType: "primitiveType";
    readonly stringType: "stringType";
    readonly typeRef: "typeRef";
};
export declare function isSimpleType(item: unknown): item is SimpleType;
export interface StringLiteral extends langium.AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}
export declare const StringLiteral: {
    readonly $type: "StringLiteral";
    readonly value: "value";
};
export declare function isStringLiteral(item: unknown): item is StringLiteral;
export interface TerminalAlternatives extends TerminalElement {
    readonly $type: 'TerminalAlternatives';
    elements: Array<AbstractElement>;
}
export declare const TerminalAlternatives: {
    readonly $type: "TerminalAlternatives";
    readonly cardinality: "cardinality";
    readonly elements: "elements";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
};
export declare function isTerminalAlternatives(item: unknown): item is TerminalAlternatives;
export interface TerminalElement extends AbstractElement {
    readonly $type: 'CharacterRange' | 'NegatedToken' | 'RegexToken' | 'TerminalAlternatives' | 'TerminalElement' | 'TerminalGroup' | 'TerminalRuleCall' | 'UntilToken' | 'Wildcard';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
    parenthesized: boolean;
}
export declare const TerminalElement: {
    readonly $type: "TerminalElement";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
};
export declare function isTerminalElement(item: unknown): item is TerminalElement;
export interface TerminalGroup extends TerminalElement {
    readonly $type: 'TerminalGroup';
    elements: Array<AbstractElement>;
}
export declare const TerminalGroup: {
    readonly $type: "TerminalGroup";
    readonly cardinality: "cardinality";
    readonly elements: "elements";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
};
export declare function isTerminalGroup(item: unknown): item is TerminalGroup;
export interface TerminalRule extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: TerminalElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType;
}
export declare const TerminalRule: {
    readonly $type: "TerminalRule";
    readonly definition: "definition";
    readonly fragment: "fragment";
    readonly hidden: "hidden";
    readonly name: "name";
    readonly type: "type";
};
export declare function isTerminalRule(item: unknown): item is TerminalRule;
export interface TerminalRuleCall extends TerminalElement {
    readonly $type: 'TerminalRuleCall';
    rule: langium.Reference<TerminalRule>;
}
export declare const TerminalRuleCall: {
    readonly $type: "TerminalRuleCall";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
    readonly rule: "rule";
};
export declare function isTerminalRuleCall(item: unknown): item is TerminalRuleCall;
export interface Type extends langium.AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}
export declare const Type: {
    readonly $type: "Type";
    readonly name: "name";
    readonly type: "type";
};
export declare function isType(item: unknown): item is Type;
export interface TypeAttribute extends langium.AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}
export declare const TypeAttribute: {
    readonly $type: "TypeAttribute";
    readonly defaultValue: "defaultValue";
    readonly isOptional: "isOptional";
    readonly name: "name";
    readonly type: "type";
};
export declare function isTypeAttribute(item: unknown): item is TypeAttribute;
export type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;
export declare const TypeDefinition: {
    readonly $type: "TypeDefinition";
};
export declare function isTypeDefinition(item: unknown): item is TypeDefinition;
export interface UnionType extends langium.AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}
export declare const UnionType: {
    readonly $type: "UnionType";
    readonly types: "types";
};
export declare function isUnionType(item: unknown): item is UnionType;
export interface UnorderedGroup extends AbstractElement {
    readonly $type: 'UnorderedGroup';
    elements: Array<AbstractElement>;
}
export declare const UnorderedGroup: {
    readonly $type: "UnorderedGroup";
    readonly cardinality: "cardinality";
    readonly elements: "elements";
};
export declare function isUnorderedGroup(item: unknown): item is UnorderedGroup;
export interface UntilToken extends TerminalElement {
    readonly $type: 'UntilToken';
    terminal: AbstractElement;
}
export declare const UntilToken: {
    readonly $type: "UntilToken";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
    readonly terminal: "terminal";
};
export declare function isUntilToken(item: unknown): item is UntilToken;
export type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;
export declare const ValueLiteral: {
    readonly $type: "ValueLiteral";
};
export declare function isValueLiteral(item: unknown): item is ValueLiteral;
export interface Wildcard extends TerminalElement {
    readonly $type: 'Wildcard';
}
export declare const Wildcard: {
    readonly $type: "Wildcard";
    readonly cardinality: "cardinality";
    readonly lookahead: "lookahead";
    readonly parenthesized: "parenthesized";
};
export declare function isWildcard(item: unknown): item is Wildcard;
export type LangiumGrammarAstType = {
    AbstractElement: AbstractElement;
    AbstractParserRule: AbstractParserRule;
    AbstractRule: AbstractRule;
    AbstractType: AbstractType;
    Action: Action;
    Alternatives: Alternatives;
    ArrayLiteral: ArrayLiteral;
    ArrayType: ArrayType;
    Assignment: Assignment;
    BooleanLiteral: BooleanLiteral;
    CharacterRange: CharacterRange;
    Condition: Condition;
    Conjunction: Conjunction;
    CrossReference: CrossReference;
    Disjunction: Disjunction;
    EndOfFile: EndOfFile;
    Grammar: Grammar;
    GrammarImport: GrammarImport;
    Group: Group;
    InferredType: InferredType;
    InfixRule: InfixRule;
    InfixRuleOperatorList: InfixRuleOperatorList;
    InfixRuleOperators: InfixRuleOperators;
    Interface: Interface;
    Keyword: Keyword;
    NamedArgument: NamedArgument;
    NegatedToken: NegatedToken;
    Negation: Negation;
    NumberLiteral: NumberLiteral;
    Parameter: Parameter;
    ParameterReference: ParameterReference;
    ParserRule: ParserRule;
    ReferenceType: ReferenceType;
    RegexToken: RegexToken;
    ReturnType: ReturnType;
    RuleCall: RuleCall;
    SimpleType: SimpleType;
    StringLiteral: StringLiteral;
    TerminalAlternatives: TerminalAlternatives;
    TerminalElement: TerminalElement;
    TerminalGroup: TerminalGroup;
    TerminalRule: TerminalRule;
    TerminalRuleCall: TerminalRuleCall;
    Type: Type;
    TypeAttribute: TypeAttribute;
    TypeDefinition: TypeDefinition;
    UnionType: UnionType;
    UnorderedGroup: UnorderedGroup;
    UntilToken: UntilToken;
    ValueLiteral: ValueLiteral;
    Wildcard: Wildcard;
};
export declare class LangiumGrammarAstReflection extends langium.AbstractAstReflection {
    readonly types: {
        readonly AbstractElement: {
            readonly name: "AbstractElement";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
            };
            readonly superTypes: [];
        };
        readonly AbstractParserRule: {
            readonly name: "AbstractParserRule";
            readonly properties: {};
            readonly superTypes: ["AbstractRule", "AbstractType"];
        };
        readonly AbstractRule: {
            readonly name: "AbstractRule";
            readonly properties: {};
            readonly superTypes: [];
        };
        readonly AbstractType: {
            readonly name: "AbstractType";
            readonly properties: {};
            readonly superTypes: [];
        };
        readonly Action: {
            readonly name: "Action";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly feature: {
                    readonly name: "feature";
                };
                readonly inferredType: {
                    readonly name: "inferredType";
                };
                readonly operator: {
                    readonly name: "operator";
                };
                readonly type: {
                    readonly name: "type";
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly Alternatives: {
            readonly name: "Alternatives";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly ArrayLiteral: {
            readonly name: "ArrayLiteral";
            readonly properties: {
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: ["ValueLiteral"];
        };
        readonly ArrayType: {
            readonly name: "ArrayType";
            readonly properties: {
                readonly elementType: {
                    readonly name: "elementType";
                };
            };
            readonly superTypes: ["TypeDefinition"];
        };
        readonly Assignment: {
            readonly name: "Assignment";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly feature: {
                    readonly name: "feature";
                };
                readonly operator: {
                    readonly name: "operator";
                };
                readonly predicate: {
                    readonly name: "predicate";
                };
                readonly terminal: {
                    readonly name: "terminal";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly BooleanLiteral: {
            readonly name: "BooleanLiteral";
            readonly properties: {
                readonly true: {
                    readonly name: "true";
                    readonly defaultValue: false;
                };
            };
            readonly superTypes: ["Condition", "ValueLiteral"];
        };
        readonly CharacterRange: {
            readonly name: "CharacterRange";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly left: {
                    readonly name: "left";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
                readonly right: {
                    readonly name: "right";
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly Condition: {
            readonly name: "Condition";
            readonly properties: {};
            readonly superTypes: [];
        };
        readonly Conjunction: {
            readonly name: "Conjunction";
            readonly properties: {
                readonly left: {
                    readonly name: "left";
                };
                readonly right: {
                    readonly name: "right";
                };
            };
            readonly superTypes: ["Condition"];
        };
        readonly CrossReference: {
            readonly name: "CrossReference";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly deprecatedSyntax: {
                    readonly name: "deprecatedSyntax";
                    readonly defaultValue: false;
                };
                readonly isMulti: {
                    readonly name: "isMulti";
                    readonly defaultValue: false;
                };
                readonly terminal: {
                    readonly name: "terminal";
                };
                readonly type: {
                    readonly name: "type";
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly Disjunction: {
            readonly name: "Disjunction";
            readonly properties: {
                readonly left: {
                    readonly name: "left";
                };
                readonly right: {
                    readonly name: "right";
                };
            };
            readonly superTypes: ["Condition"];
        };
        readonly EndOfFile: {
            readonly name: "EndOfFile";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly Grammar: {
            readonly name: "Grammar";
            readonly properties: {
                readonly imports: {
                    readonly name: "imports";
                    readonly defaultValue: [];
                };
                readonly interfaces: {
                    readonly name: "interfaces";
                    readonly defaultValue: [];
                };
                readonly isDeclared: {
                    readonly name: "isDeclared";
                    readonly defaultValue: false;
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly rules: {
                    readonly name: "rules";
                    readonly defaultValue: [];
                };
                readonly types: {
                    readonly name: "types";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: [];
        };
        readonly GrammarImport: {
            readonly name: "GrammarImport";
            readonly properties: {
                readonly path: {
                    readonly name: "path";
                };
            };
            readonly superTypes: [];
        };
        readonly Group: {
            readonly name: "Group";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
                readonly guardCondition: {
                    readonly name: "guardCondition";
                };
                readonly predicate: {
                    readonly name: "predicate";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly InferredType: {
            readonly name: "InferredType";
            readonly properties: {
                readonly name: {
                    readonly name: "name";
                };
            };
            readonly superTypes: ["AbstractType"];
        };
        readonly InfixRule: {
            readonly name: "InfixRule";
            readonly properties: {
                readonly call: {
                    readonly name: "call";
                };
                readonly dataType: {
                    readonly name: "dataType";
                };
                readonly inferredType: {
                    readonly name: "inferredType";
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly operators: {
                    readonly name: "operators";
                };
                readonly parameters: {
                    readonly name: "parameters";
                    readonly defaultValue: [];
                };
                readonly returnType: {
                    readonly name: "returnType";
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["AbstractParserRule"];
        };
        readonly InfixRuleOperatorList: {
            readonly name: "InfixRuleOperatorList";
            readonly properties: {
                readonly associativity: {
                    readonly name: "associativity";
                };
                readonly operators: {
                    readonly name: "operators";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: [];
        };
        readonly InfixRuleOperators: {
            readonly name: "InfixRuleOperators";
            readonly properties: {
                readonly precedences: {
                    readonly name: "precedences";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: [];
        };
        readonly Interface: {
            readonly name: "Interface";
            readonly properties: {
                readonly attributes: {
                    readonly name: "attributes";
                    readonly defaultValue: [];
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly superTypes: {
                    readonly name: "superTypes";
                    readonly defaultValue: [];
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["AbstractType"];
        };
        readonly Keyword: {
            readonly name: "Keyword";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly predicate: {
                    readonly name: "predicate";
                };
                readonly value: {
                    readonly name: "value";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly NamedArgument: {
            readonly name: "NamedArgument";
            readonly properties: {
                readonly calledByName: {
                    readonly name: "calledByName";
                    readonly defaultValue: false;
                };
                readonly parameter: {
                    readonly name: "parameter";
                    readonly referenceType: "Parameter";
                };
                readonly value: {
                    readonly name: "value";
                };
            };
            readonly superTypes: [];
        };
        readonly NegatedToken: {
            readonly name: "NegatedToken";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
                readonly terminal: {
                    readonly name: "terminal";
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly Negation: {
            readonly name: "Negation";
            readonly properties: {
                readonly value: {
                    readonly name: "value";
                };
            };
            readonly superTypes: ["Condition"];
        };
        readonly NumberLiteral: {
            readonly name: "NumberLiteral";
            readonly properties: {
                readonly value: {
                    readonly name: "value";
                };
            };
            readonly superTypes: ["ValueLiteral"];
        };
        readonly Parameter: {
            readonly name: "Parameter";
            readonly properties: {
                readonly name: {
                    readonly name: "name";
                };
            };
            readonly superTypes: [];
        };
        readonly ParameterReference: {
            readonly name: "ParameterReference";
            readonly properties: {
                readonly parameter: {
                    readonly name: "parameter";
                    readonly referenceType: "Parameter";
                };
            };
            readonly superTypes: ["Condition"];
        };
        readonly ParserRule: {
            readonly name: "ParserRule";
            readonly properties: {
                readonly dataType: {
                    readonly name: "dataType";
                };
                readonly definition: {
                    readonly name: "definition";
                };
                readonly entry: {
                    readonly name: "entry";
                    readonly defaultValue: false;
                };
                readonly fragment: {
                    readonly name: "fragment";
                    readonly defaultValue: false;
                };
                readonly inferredType: {
                    readonly name: "inferredType";
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly parameters: {
                    readonly name: "parameters";
                    readonly defaultValue: [];
                };
                readonly returnType: {
                    readonly name: "returnType";
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["AbstractParserRule"];
        };
        readonly ReferenceType: {
            readonly name: "ReferenceType";
            readonly properties: {
                readonly isMulti: {
                    readonly name: "isMulti";
                    readonly defaultValue: false;
                };
                readonly referenceType: {
                    readonly name: "referenceType";
                };
            };
            readonly superTypes: ["TypeDefinition"];
        };
        readonly RegexToken: {
            readonly name: "RegexToken";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
                readonly regex: {
                    readonly name: "regex";
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly ReturnType: {
            readonly name: "ReturnType";
            readonly properties: {
                readonly name: {
                    readonly name: "name";
                };
            };
            readonly superTypes: [];
        };
        readonly RuleCall: {
            readonly name: "RuleCall";
            readonly properties: {
                readonly arguments: {
                    readonly name: "arguments";
                    readonly defaultValue: [];
                };
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly predicate: {
                    readonly name: "predicate";
                };
                readonly rule: {
                    readonly name: "rule";
                    readonly referenceType: "AbstractRule";
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly SimpleType: {
            readonly name: "SimpleType";
            readonly properties: {
                readonly primitiveType: {
                    readonly name: "primitiveType";
                };
                readonly stringType: {
                    readonly name: "stringType";
                };
                readonly typeRef: {
                    readonly name: "typeRef";
                    readonly referenceType: "AbstractType";
                };
            };
            readonly superTypes: ["TypeDefinition"];
        };
        readonly StringLiteral: {
            readonly name: "StringLiteral";
            readonly properties: {
                readonly value: {
                    readonly name: "value";
                };
            };
            readonly superTypes: ["ValueLiteral"];
        };
        readonly TerminalAlternatives: {
            readonly name: "TerminalAlternatives";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly TerminalElement: {
            readonly name: "TerminalElement";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly TerminalGroup: {
            readonly name: "TerminalGroup";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly TerminalRule: {
            readonly name: "TerminalRule";
            readonly properties: {
                readonly definition: {
                    readonly name: "definition";
                };
                readonly fragment: {
                    readonly name: "fragment";
                    readonly defaultValue: false;
                };
                readonly hidden: {
                    readonly name: "hidden";
                    readonly defaultValue: false;
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly type: {
                    readonly name: "type";
                };
            };
            readonly superTypes: ["AbstractRule"];
        };
        readonly TerminalRuleCall: {
            readonly name: "TerminalRuleCall";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
                readonly rule: {
                    readonly name: "rule";
                    readonly referenceType: "TerminalRule";
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly Type: {
            readonly name: "Type";
            readonly properties: {
                readonly name: {
                    readonly name: "name";
                };
                readonly type: {
                    readonly name: "type";
                };
            };
            readonly superTypes: ["AbstractType"];
        };
        readonly TypeAttribute: {
            readonly name: "TypeAttribute";
            readonly properties: {
                readonly defaultValue: {
                    readonly name: "defaultValue";
                };
                readonly isOptional: {
                    readonly name: "isOptional";
                    readonly defaultValue: false;
                };
                readonly name: {
                    readonly name: "name";
                };
                readonly type: {
                    readonly name: "type";
                };
            };
            readonly superTypes: [];
        };
        readonly TypeDefinition: {
            readonly name: "TypeDefinition";
            readonly properties: {};
            readonly superTypes: [];
        };
        readonly UnionType: {
            readonly name: "UnionType";
            readonly properties: {
                readonly types: {
                    readonly name: "types";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: ["TypeDefinition"];
        };
        readonly UnorderedGroup: {
            readonly name: "UnorderedGroup";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly elements: {
                    readonly name: "elements";
                    readonly defaultValue: [];
                };
            };
            readonly superTypes: ["AbstractElement"];
        };
        readonly UntilToken: {
            readonly name: "UntilToken";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
                readonly terminal: {
                    readonly name: "terminal";
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
        readonly ValueLiteral: {
            readonly name: "ValueLiteral";
            readonly properties: {};
            readonly superTypes: [];
        };
        readonly Wildcard: {
            readonly name: "Wildcard";
            readonly properties: {
                readonly cardinality: {
                    readonly name: "cardinality";
                };
                readonly lookahead: {
                    readonly name: "lookahead";
                };
                readonly parenthesized: {
                    readonly name: "parenthesized";
                    readonly defaultValue: false;
                };
            };
            readonly superTypes: ["TerminalElement"];
        };
    };
}
export declare const reflection: LangiumGrammarAstReflection;
//# sourceMappingURL=ast.d.ts.map