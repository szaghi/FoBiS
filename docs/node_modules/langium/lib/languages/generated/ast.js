/******************************************************************************
 * This file was generated by langium-cli 4.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
/* eslint-disable */
import * as langium from '../../syntax-tree.js';
export const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
export const AbstractElement = {
    $type: 'AbstractElement',
    cardinality: 'cardinality'
};
export function isAbstractElement(item) {
    return reflection.isInstance(item, AbstractElement.$type);
}
export const AbstractParserRule = {
    $type: 'AbstractParserRule'
};
export function isAbstractParserRule(item) {
    return reflection.isInstance(item, AbstractParserRule.$type);
}
export const AbstractRule = {
    $type: 'AbstractRule'
};
export function isAbstractRule(item) {
    return reflection.isInstance(item, AbstractRule.$type);
}
export const AbstractType = {
    $type: 'AbstractType'
};
export function isAbstractType(item) {
    return reflection.isInstance(item, AbstractType.$type);
}
export const Action = {
    $type: 'Action',
    cardinality: 'cardinality',
    feature: 'feature',
    inferredType: 'inferredType',
    operator: 'operator',
    type: 'type'
};
export function isAction(item) {
    return reflection.isInstance(item, Action.$type);
}
export const Alternatives = {
    $type: 'Alternatives',
    cardinality: 'cardinality',
    elements: 'elements'
};
export function isAlternatives(item) {
    return reflection.isInstance(item, Alternatives.$type);
}
export const ArrayLiteral = {
    $type: 'ArrayLiteral',
    elements: 'elements'
};
export function isArrayLiteral(item) {
    return reflection.isInstance(item, ArrayLiteral.$type);
}
export const ArrayType = {
    $type: 'ArrayType',
    elementType: 'elementType'
};
export function isArrayType(item) {
    return reflection.isInstance(item, ArrayType.$type);
}
export const Assignment = {
    $type: 'Assignment',
    cardinality: 'cardinality',
    feature: 'feature',
    operator: 'operator',
    predicate: 'predicate',
    terminal: 'terminal'
};
export function isAssignment(item) {
    return reflection.isInstance(item, Assignment.$type);
}
export const BooleanLiteral = {
    $type: 'BooleanLiteral',
    true: 'true'
};
export function isBooleanLiteral(item) {
    return reflection.isInstance(item, BooleanLiteral.$type);
}
export const CharacterRange = {
    $type: 'CharacterRange',
    cardinality: 'cardinality',
    left: 'left',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    right: 'right'
};
export function isCharacterRange(item) {
    return reflection.isInstance(item, CharacterRange.$type);
}
export const Condition = {
    $type: 'Condition'
};
export function isCondition(item) {
    return reflection.isInstance(item, Condition.$type);
}
export const Conjunction = {
    $type: 'Conjunction',
    left: 'left',
    right: 'right'
};
export function isConjunction(item) {
    return reflection.isInstance(item, Conjunction.$type);
}
export const CrossReference = {
    $type: 'CrossReference',
    cardinality: 'cardinality',
    deprecatedSyntax: 'deprecatedSyntax',
    isMulti: 'isMulti',
    terminal: 'terminal',
    type: 'type'
};
export function isCrossReference(item) {
    return reflection.isInstance(item, CrossReference.$type);
}
export const Disjunction = {
    $type: 'Disjunction',
    left: 'left',
    right: 'right'
};
export function isDisjunction(item) {
    return reflection.isInstance(item, Disjunction.$type);
}
export const EndOfFile = {
    $type: 'EndOfFile',
    cardinality: 'cardinality'
};
export function isEndOfFile(item) {
    return reflection.isInstance(item, EndOfFile.$type);
}
export const Grammar = {
    $type: 'Grammar',
    imports: 'imports',
    interfaces: 'interfaces',
    isDeclared: 'isDeclared',
    name: 'name',
    rules: 'rules',
    types: 'types'
};
export function isGrammar(item) {
    return reflection.isInstance(item, Grammar.$type);
}
export const GrammarImport = {
    $type: 'GrammarImport',
    path: 'path'
};
export function isGrammarImport(item) {
    return reflection.isInstance(item, GrammarImport.$type);
}
export const Group = {
    $type: 'Group',
    cardinality: 'cardinality',
    elements: 'elements',
    guardCondition: 'guardCondition',
    predicate: 'predicate'
};
export function isGroup(item) {
    return reflection.isInstance(item, Group.$type);
}
export const InferredType = {
    $type: 'InferredType',
    name: 'name'
};
export function isInferredType(item) {
    return reflection.isInstance(item, InferredType.$type);
}
export const InfixRule = {
    $type: 'InfixRule',
    call: 'call',
    dataType: 'dataType',
    inferredType: 'inferredType',
    name: 'name',
    operators: 'operators',
    parameters: 'parameters',
    returnType: 'returnType'
};
export function isInfixRule(item) {
    return reflection.isInstance(item, InfixRule.$type);
}
export const InfixRuleOperatorList = {
    $type: 'InfixRuleOperatorList',
    associativity: 'associativity',
    operators: 'operators'
};
export function isInfixRuleOperatorList(item) {
    return reflection.isInstance(item, InfixRuleOperatorList.$type);
}
export const InfixRuleOperators = {
    $type: 'InfixRuleOperators',
    precedences: 'precedences'
};
export function isInfixRuleOperators(item) {
    return reflection.isInstance(item, InfixRuleOperators.$type);
}
export const Interface = {
    $type: 'Interface',
    attributes: 'attributes',
    name: 'name',
    superTypes: 'superTypes'
};
export function isInterface(item) {
    return reflection.isInstance(item, Interface.$type);
}
export const Keyword = {
    $type: 'Keyword',
    cardinality: 'cardinality',
    predicate: 'predicate',
    value: 'value'
};
export function isKeyword(item) {
    return reflection.isInstance(item, Keyword.$type);
}
export const NamedArgument = {
    $type: 'NamedArgument',
    calledByName: 'calledByName',
    parameter: 'parameter',
    value: 'value'
};
export function isNamedArgument(item) {
    return reflection.isInstance(item, NamedArgument.$type);
}
export const NegatedToken = {
    $type: 'NegatedToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    terminal: 'terminal'
};
export function isNegatedToken(item) {
    return reflection.isInstance(item, NegatedToken.$type);
}
export const Negation = {
    $type: 'Negation',
    value: 'value'
};
export function isNegation(item) {
    return reflection.isInstance(item, Negation.$type);
}
export const NumberLiteral = {
    $type: 'NumberLiteral',
    value: 'value'
};
export function isNumberLiteral(item) {
    return reflection.isInstance(item, NumberLiteral.$type);
}
export const Parameter = {
    $type: 'Parameter',
    name: 'name'
};
export function isParameter(item) {
    return reflection.isInstance(item, Parameter.$type);
}
export const ParameterReference = {
    $type: 'ParameterReference',
    parameter: 'parameter'
};
export function isParameterReference(item) {
    return reflection.isInstance(item, ParameterReference.$type);
}
export const ParserRule = {
    $type: 'ParserRule',
    dataType: 'dataType',
    definition: 'definition',
    entry: 'entry',
    fragment: 'fragment',
    inferredType: 'inferredType',
    name: 'name',
    parameters: 'parameters',
    returnType: 'returnType'
};
export function isParserRule(item) {
    return reflection.isInstance(item, ParserRule.$type);
}
export const ReferenceType = {
    $type: 'ReferenceType',
    isMulti: 'isMulti',
    referenceType: 'referenceType'
};
export function isReferenceType(item) {
    return reflection.isInstance(item, ReferenceType.$type);
}
export const RegexToken = {
    $type: 'RegexToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    regex: 'regex'
};
export function isRegexToken(item) {
    return reflection.isInstance(item, RegexToken.$type);
}
export const ReturnType = {
    $type: 'ReturnType',
    name: 'name'
};
export function isReturnType(item) {
    return reflection.isInstance(item, ReturnType.$type);
}
export const RuleCall = {
    $type: 'RuleCall',
    arguments: 'arguments',
    cardinality: 'cardinality',
    predicate: 'predicate',
    rule: 'rule'
};
export function isRuleCall(item) {
    return reflection.isInstance(item, RuleCall.$type);
}
export const SimpleType = {
    $type: 'SimpleType',
    primitiveType: 'primitiveType',
    stringType: 'stringType',
    typeRef: 'typeRef'
};
export function isSimpleType(item) {
    return reflection.isInstance(item, SimpleType.$type);
}
export const StringLiteral = {
    $type: 'StringLiteral',
    value: 'value'
};
export function isStringLiteral(item) {
    return reflection.isInstance(item, StringLiteral.$type);
}
export const TerminalAlternatives = {
    $type: 'TerminalAlternatives',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
};
export function isTerminalAlternatives(item) {
    return reflection.isInstance(item, TerminalAlternatives.$type);
}
export const TerminalElement = {
    $type: 'TerminalElement',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
};
export function isTerminalElement(item) {
    return reflection.isInstance(item, TerminalElement.$type);
}
export const TerminalGroup = {
    $type: 'TerminalGroup',
    cardinality: 'cardinality',
    elements: 'elements',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
};
export function isTerminalGroup(item) {
    return reflection.isInstance(item, TerminalGroup.$type);
}
export const TerminalRule = {
    $type: 'TerminalRule',
    definition: 'definition',
    fragment: 'fragment',
    hidden: 'hidden',
    name: 'name',
    type: 'type'
};
export function isTerminalRule(item) {
    return reflection.isInstance(item, TerminalRule.$type);
}
export const TerminalRuleCall = {
    $type: 'TerminalRuleCall',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    rule: 'rule'
};
export function isTerminalRuleCall(item) {
    return reflection.isInstance(item, TerminalRuleCall.$type);
}
export const Type = {
    $type: 'Type',
    name: 'name',
    type: 'type'
};
export function isType(item) {
    return reflection.isInstance(item, Type.$type);
}
export const TypeAttribute = {
    $type: 'TypeAttribute',
    defaultValue: 'defaultValue',
    isOptional: 'isOptional',
    name: 'name',
    type: 'type'
};
export function isTypeAttribute(item) {
    return reflection.isInstance(item, TypeAttribute.$type);
}
export const TypeDefinition = {
    $type: 'TypeDefinition'
};
export function isTypeDefinition(item) {
    return reflection.isInstance(item, TypeDefinition.$type);
}
export const UnionType = {
    $type: 'UnionType',
    types: 'types'
};
export function isUnionType(item) {
    return reflection.isInstance(item, UnionType.$type);
}
export const UnorderedGroup = {
    $type: 'UnorderedGroup',
    cardinality: 'cardinality',
    elements: 'elements'
};
export function isUnorderedGroup(item) {
    return reflection.isInstance(item, UnorderedGroup.$type);
}
export const UntilToken = {
    $type: 'UntilToken',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized',
    terminal: 'terminal'
};
export function isUntilToken(item) {
    return reflection.isInstance(item, UntilToken.$type);
}
export const ValueLiteral = {
    $type: 'ValueLiteral'
};
export function isValueLiteral(item) {
    return reflection.isInstance(item, ValueLiteral.$type);
}
export const Wildcard = {
    $type: 'Wildcard',
    cardinality: 'cardinality',
    lookahead: 'lookahead',
    parenthesized: 'parenthesized'
};
export function isWildcard(item) {
    return reflection.isInstance(item, Wildcard.$type);
}
export class LangiumGrammarAstReflection extends langium.AbstractAstReflection {
    constructor() {
        super(...arguments);
        this.types = {
            AbstractElement: {
                name: AbstractElement.$type,
                properties: {
                    cardinality: {
                        name: AbstractElement.cardinality
                    }
                },
                superTypes: []
            },
            AbstractParserRule: {
                name: AbstractParserRule.$type,
                properties: {},
                superTypes: [AbstractRule.$type, AbstractType.$type]
            },
            AbstractRule: {
                name: AbstractRule.$type,
                properties: {},
                superTypes: []
            },
            AbstractType: {
                name: AbstractType.$type,
                properties: {},
                superTypes: []
            },
            Action: {
                name: Action.$type,
                properties: {
                    cardinality: {
                        name: Action.cardinality
                    },
                    feature: {
                        name: Action.feature
                    },
                    inferredType: {
                        name: Action.inferredType
                    },
                    operator: {
                        name: Action.operator
                    },
                    type: {
                        name: Action.type,
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            Alternatives: {
                name: Alternatives.$type,
                properties: {
                    cardinality: {
                        name: Alternatives.cardinality
                    },
                    elements: {
                        name: Alternatives.elements,
                        defaultValue: []
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            ArrayLiteral: {
                name: ArrayLiteral.$type,
                properties: {
                    elements: {
                        name: ArrayLiteral.elements,
                        defaultValue: []
                    }
                },
                superTypes: [ValueLiteral.$type]
            },
            ArrayType: {
                name: ArrayType.$type,
                properties: {
                    elementType: {
                        name: ArrayType.elementType
                    }
                },
                superTypes: [TypeDefinition.$type]
            },
            Assignment: {
                name: Assignment.$type,
                properties: {
                    cardinality: {
                        name: Assignment.cardinality
                    },
                    feature: {
                        name: Assignment.feature
                    },
                    operator: {
                        name: Assignment.operator
                    },
                    predicate: {
                        name: Assignment.predicate
                    },
                    terminal: {
                        name: Assignment.terminal
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            BooleanLiteral: {
                name: BooleanLiteral.$type,
                properties: {
                    true: {
                        name: BooleanLiteral.true,
                        defaultValue: false
                    }
                },
                superTypes: [Condition.$type, ValueLiteral.$type]
            },
            CharacterRange: {
                name: CharacterRange.$type,
                properties: {
                    cardinality: {
                        name: CharacterRange.cardinality
                    },
                    left: {
                        name: CharacterRange.left
                    },
                    lookahead: {
                        name: CharacterRange.lookahead
                    },
                    parenthesized: {
                        name: CharacterRange.parenthesized,
                        defaultValue: false
                    },
                    right: {
                        name: CharacterRange.right
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            Condition: {
                name: Condition.$type,
                properties: {},
                superTypes: []
            },
            Conjunction: {
                name: Conjunction.$type,
                properties: {
                    left: {
                        name: Conjunction.left
                    },
                    right: {
                        name: Conjunction.right
                    }
                },
                superTypes: [Condition.$type]
            },
            CrossReference: {
                name: CrossReference.$type,
                properties: {
                    cardinality: {
                        name: CrossReference.cardinality
                    },
                    deprecatedSyntax: {
                        name: CrossReference.deprecatedSyntax,
                        defaultValue: false
                    },
                    isMulti: {
                        name: CrossReference.isMulti,
                        defaultValue: false
                    },
                    terminal: {
                        name: CrossReference.terminal
                    },
                    type: {
                        name: CrossReference.type,
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            Disjunction: {
                name: Disjunction.$type,
                properties: {
                    left: {
                        name: Disjunction.left
                    },
                    right: {
                        name: Disjunction.right
                    }
                },
                superTypes: [Condition.$type]
            },
            EndOfFile: {
                name: EndOfFile.$type,
                properties: {
                    cardinality: {
                        name: EndOfFile.cardinality
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            Grammar: {
                name: Grammar.$type,
                properties: {
                    imports: {
                        name: Grammar.imports,
                        defaultValue: []
                    },
                    interfaces: {
                        name: Grammar.interfaces,
                        defaultValue: []
                    },
                    isDeclared: {
                        name: Grammar.isDeclared,
                        defaultValue: false
                    },
                    name: {
                        name: Grammar.name
                    },
                    rules: {
                        name: Grammar.rules,
                        defaultValue: []
                    },
                    types: {
                        name: Grammar.types,
                        defaultValue: []
                    }
                },
                superTypes: []
            },
            GrammarImport: {
                name: GrammarImport.$type,
                properties: {
                    path: {
                        name: GrammarImport.path
                    }
                },
                superTypes: []
            },
            Group: {
                name: Group.$type,
                properties: {
                    cardinality: {
                        name: Group.cardinality
                    },
                    elements: {
                        name: Group.elements,
                        defaultValue: []
                    },
                    guardCondition: {
                        name: Group.guardCondition
                    },
                    predicate: {
                        name: Group.predicate
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            InferredType: {
                name: InferredType.$type,
                properties: {
                    name: {
                        name: InferredType.name
                    }
                },
                superTypes: [AbstractType.$type]
            },
            InfixRule: {
                name: InfixRule.$type,
                properties: {
                    call: {
                        name: InfixRule.call
                    },
                    dataType: {
                        name: InfixRule.dataType
                    },
                    inferredType: {
                        name: InfixRule.inferredType
                    },
                    name: {
                        name: InfixRule.name
                    },
                    operators: {
                        name: InfixRule.operators
                    },
                    parameters: {
                        name: InfixRule.parameters,
                        defaultValue: []
                    },
                    returnType: {
                        name: InfixRule.returnType,
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [AbstractParserRule.$type]
            },
            InfixRuleOperatorList: {
                name: InfixRuleOperatorList.$type,
                properties: {
                    associativity: {
                        name: InfixRuleOperatorList.associativity
                    },
                    operators: {
                        name: InfixRuleOperatorList.operators,
                        defaultValue: []
                    }
                },
                superTypes: []
            },
            InfixRuleOperators: {
                name: InfixRuleOperators.$type,
                properties: {
                    precedences: {
                        name: InfixRuleOperators.precedences,
                        defaultValue: []
                    }
                },
                superTypes: []
            },
            Interface: {
                name: Interface.$type,
                properties: {
                    attributes: {
                        name: Interface.attributes,
                        defaultValue: []
                    },
                    name: {
                        name: Interface.name
                    },
                    superTypes: {
                        name: Interface.superTypes,
                        defaultValue: [],
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [AbstractType.$type]
            },
            Keyword: {
                name: Keyword.$type,
                properties: {
                    cardinality: {
                        name: Keyword.cardinality
                    },
                    predicate: {
                        name: Keyword.predicate
                    },
                    value: {
                        name: Keyword.value
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            NamedArgument: {
                name: NamedArgument.$type,
                properties: {
                    calledByName: {
                        name: NamedArgument.calledByName,
                        defaultValue: false
                    },
                    parameter: {
                        name: NamedArgument.parameter,
                        referenceType: Parameter.$type
                    },
                    value: {
                        name: NamedArgument.value
                    }
                },
                superTypes: []
            },
            NegatedToken: {
                name: NegatedToken.$type,
                properties: {
                    cardinality: {
                        name: NegatedToken.cardinality
                    },
                    lookahead: {
                        name: NegatedToken.lookahead
                    },
                    parenthesized: {
                        name: NegatedToken.parenthesized,
                        defaultValue: false
                    },
                    terminal: {
                        name: NegatedToken.terminal
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            Negation: {
                name: Negation.$type,
                properties: {
                    value: {
                        name: Negation.value
                    }
                },
                superTypes: [Condition.$type]
            },
            NumberLiteral: {
                name: NumberLiteral.$type,
                properties: {
                    value: {
                        name: NumberLiteral.value
                    }
                },
                superTypes: [ValueLiteral.$type]
            },
            Parameter: {
                name: Parameter.$type,
                properties: {
                    name: {
                        name: Parameter.name
                    }
                },
                superTypes: []
            },
            ParameterReference: {
                name: ParameterReference.$type,
                properties: {
                    parameter: {
                        name: ParameterReference.parameter,
                        referenceType: Parameter.$type
                    }
                },
                superTypes: [Condition.$type]
            },
            ParserRule: {
                name: ParserRule.$type,
                properties: {
                    dataType: {
                        name: ParserRule.dataType
                    },
                    definition: {
                        name: ParserRule.definition
                    },
                    entry: {
                        name: ParserRule.entry,
                        defaultValue: false
                    },
                    fragment: {
                        name: ParserRule.fragment,
                        defaultValue: false
                    },
                    inferredType: {
                        name: ParserRule.inferredType
                    },
                    name: {
                        name: ParserRule.name
                    },
                    parameters: {
                        name: ParserRule.parameters,
                        defaultValue: []
                    },
                    returnType: {
                        name: ParserRule.returnType,
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [AbstractParserRule.$type]
            },
            ReferenceType: {
                name: ReferenceType.$type,
                properties: {
                    isMulti: {
                        name: ReferenceType.isMulti,
                        defaultValue: false
                    },
                    referenceType: {
                        name: ReferenceType.referenceType
                    }
                },
                superTypes: [TypeDefinition.$type]
            },
            RegexToken: {
                name: RegexToken.$type,
                properties: {
                    cardinality: {
                        name: RegexToken.cardinality
                    },
                    lookahead: {
                        name: RegexToken.lookahead
                    },
                    parenthesized: {
                        name: RegexToken.parenthesized,
                        defaultValue: false
                    },
                    regex: {
                        name: RegexToken.regex
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            ReturnType: {
                name: ReturnType.$type,
                properties: {
                    name: {
                        name: ReturnType.name
                    }
                },
                superTypes: []
            },
            RuleCall: {
                name: RuleCall.$type,
                properties: {
                    arguments: {
                        name: RuleCall.arguments,
                        defaultValue: []
                    },
                    cardinality: {
                        name: RuleCall.cardinality
                    },
                    predicate: {
                        name: RuleCall.predicate
                    },
                    rule: {
                        name: RuleCall.rule,
                        referenceType: AbstractRule.$type
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            SimpleType: {
                name: SimpleType.$type,
                properties: {
                    primitiveType: {
                        name: SimpleType.primitiveType
                    },
                    stringType: {
                        name: SimpleType.stringType
                    },
                    typeRef: {
                        name: SimpleType.typeRef,
                        referenceType: AbstractType.$type
                    }
                },
                superTypes: [TypeDefinition.$type]
            },
            StringLiteral: {
                name: StringLiteral.$type,
                properties: {
                    value: {
                        name: StringLiteral.value
                    }
                },
                superTypes: [ValueLiteral.$type]
            },
            TerminalAlternatives: {
                name: TerminalAlternatives.$type,
                properties: {
                    cardinality: {
                        name: TerminalAlternatives.cardinality
                    },
                    elements: {
                        name: TerminalAlternatives.elements,
                        defaultValue: []
                    },
                    lookahead: {
                        name: TerminalAlternatives.lookahead
                    },
                    parenthesized: {
                        name: TerminalAlternatives.parenthesized,
                        defaultValue: false
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            TerminalElement: {
                name: TerminalElement.$type,
                properties: {
                    cardinality: {
                        name: TerminalElement.cardinality
                    },
                    lookahead: {
                        name: TerminalElement.lookahead
                    },
                    parenthesized: {
                        name: TerminalElement.parenthesized,
                        defaultValue: false
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            TerminalGroup: {
                name: TerminalGroup.$type,
                properties: {
                    cardinality: {
                        name: TerminalGroup.cardinality
                    },
                    elements: {
                        name: TerminalGroup.elements,
                        defaultValue: []
                    },
                    lookahead: {
                        name: TerminalGroup.lookahead
                    },
                    parenthesized: {
                        name: TerminalGroup.parenthesized,
                        defaultValue: false
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            TerminalRule: {
                name: TerminalRule.$type,
                properties: {
                    definition: {
                        name: TerminalRule.definition
                    },
                    fragment: {
                        name: TerminalRule.fragment,
                        defaultValue: false
                    },
                    hidden: {
                        name: TerminalRule.hidden,
                        defaultValue: false
                    },
                    name: {
                        name: TerminalRule.name
                    },
                    type: {
                        name: TerminalRule.type
                    }
                },
                superTypes: [AbstractRule.$type]
            },
            TerminalRuleCall: {
                name: TerminalRuleCall.$type,
                properties: {
                    cardinality: {
                        name: TerminalRuleCall.cardinality
                    },
                    lookahead: {
                        name: TerminalRuleCall.lookahead
                    },
                    parenthesized: {
                        name: TerminalRuleCall.parenthesized,
                        defaultValue: false
                    },
                    rule: {
                        name: TerminalRuleCall.rule,
                        referenceType: TerminalRule.$type
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            Type: {
                name: Type.$type,
                properties: {
                    name: {
                        name: Type.name
                    },
                    type: {
                        name: Type.type
                    }
                },
                superTypes: [AbstractType.$type]
            },
            TypeAttribute: {
                name: TypeAttribute.$type,
                properties: {
                    defaultValue: {
                        name: TypeAttribute.defaultValue
                    },
                    isOptional: {
                        name: TypeAttribute.isOptional,
                        defaultValue: false
                    },
                    name: {
                        name: TypeAttribute.name
                    },
                    type: {
                        name: TypeAttribute.type
                    }
                },
                superTypes: []
            },
            TypeDefinition: {
                name: TypeDefinition.$type,
                properties: {},
                superTypes: []
            },
            UnionType: {
                name: UnionType.$type,
                properties: {
                    types: {
                        name: UnionType.types,
                        defaultValue: []
                    }
                },
                superTypes: [TypeDefinition.$type]
            },
            UnorderedGroup: {
                name: UnorderedGroup.$type,
                properties: {
                    cardinality: {
                        name: UnorderedGroup.cardinality
                    },
                    elements: {
                        name: UnorderedGroup.elements,
                        defaultValue: []
                    }
                },
                superTypes: [AbstractElement.$type]
            },
            UntilToken: {
                name: UntilToken.$type,
                properties: {
                    cardinality: {
                        name: UntilToken.cardinality
                    },
                    lookahead: {
                        name: UntilToken.lookahead
                    },
                    parenthesized: {
                        name: UntilToken.parenthesized,
                        defaultValue: false
                    },
                    terminal: {
                        name: UntilToken.terminal
                    }
                },
                superTypes: [TerminalElement.$type]
            },
            ValueLiteral: {
                name: ValueLiteral.$type,
                properties: {},
                superTypes: []
            },
            Wildcard: {
                name: Wildcard.$type,
                properties: {
                    cardinality: {
                        name: Wildcard.cardinality
                    },
                    lookahead: {
                        name: Wildcard.lookahead
                    },
                    parenthesized: {
                        name: Wildcard.parenthesized,
                        defaultValue: false
                    }
                },
                superTypes: [TerminalElement.$type]
            }
        };
    }
}
export const reflection = new LangiumGrammarAstReflection();
//# sourceMappingURL=ast.js.map